#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Modified from:

Created on Mon May  6 13:52:09 2019

@author: hershe

Takes as input a file with pairwise alignments generated by
the C++ sam2pairwise utility written by Matthew C. LaFave.

Creates a data frame that has the necessary features for my
preprocessing pipeline for model predictions.

Written for use in a Snakemake pipeline.

(written to be faster than parse_pairwise.py by make all the rows, and then
only creating a dataframe once.)

(written to be faster than parse_pairwise2.py by not iterating over the rows
in the data frame to add alignment scores.)

"""

import sys
import pandas as pd
import itertools

# create list to add dictionaries of rows
rows_list = []

# read in 4 rows at a time from the sam2pairwise output file,
# create a dictionary from the reconstructed alignment, add it
# to the list
with open(sys.argv[1]) as f:
    for probe_ID, parent, aligns, reference in itertools.zip_longest(*[f]*4):
        # create a dictionary to store the row
        row_dict = {}
        row_dict.update(probe_ID = probe_ID.split('\t')[0],
                        parent = str(parent.strip()),
                        derived = str(reference.strip()),
                        align_chr = probe_ID.split('\t')[2],
                        align_start = probe_ID.split('\t')[3])
        rows_list.append(row_dict)

# make a data frame from the list of rows
df = pd.DataFrame(rows_list, columns = ['probe_ID',
                                        'parent',
                                        'derived',
                                        'align_chr',
                                        'align_start'])

# list comprehension to get the alignment scores from the text file
AS_list = [line.split(':')[2].strip() for line in open(sys.argv[2])]

# use the list to create a column
df['bowtie'] = AS_list

# filter out candidates with 100 alignments
df = df.groupby('probe_ID').filter(lambda x: len(x) < 100)

# open the .GTF and extract the header and target start-end
targets = {}

with open(sys.argv[3], 'r') as t:
    for line in t:
        targets[line.strip().split('\t')[0]] = (line.strip().split('\t')[3],line.strip().split('\t')[4])

# check if the entire alignment is inside the target region
def compare_coords(location, derived_start, derived_length) -> bool:
    if (targets[location][0] <= align_start <= targets[location][1]) & ((derived_start + derived_lenght) <= targets[location][1]):
        return True
    else:
        return False

# compute whether or not the alignment is on target
def on_target(row):
    if row['probe_ID'].split(':')[0] in targets: # is in the correct genome and contig
        gen_con = targets[row['probe_ID'].split(':')[0]]
        alignment_start = row['align_start']
        alignment_length = len(row['derived'])
        if compare_coords(gen_con, alignment_start, alignment_length) == True: # is inside the target region
            return 1
        else:
            return 0
    else:
        return 0

df['on_target'] = df.apply(on_target, axis = 1)

# save data frame to disk
df.to_csv(sys.argv[4], index_label=False)
